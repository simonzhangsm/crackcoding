\chapter{字符串}


\section{字符串API} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
面试中经常会出现，现场编写 \fn{strcpy, strlen, strstr, atoi} 等库函数的题目。这类题目看起来简单，实则难度很大，区分都很高，很容易考察出你的编程功底，是面试官的最爱。


\subsection{strlen}


【解题思路】
实现 \fn{strlen}，获取字符串长度，函数原型如下：
\begin{Code}
size_t strlen(const char *str);
\end{Code}


\subsubsection{分析}



\subsubsection{代码}
\begin{Code}
size_t strlen(const char *str) {
    const char *s;
    for (s = str; *s; ++s) {}
    return(s - str);
}
\end{Code}


\subsection{strcpy}


【解题思路】
实现 \fn{strcpy}，字符串拷贝函数，函数原型如下：
\begin{Code}
char* strcpy(char *to, const char *from);
\end{Code}


\subsubsection{分析}



\subsubsection{代码}
\begin{Code}
char* strcpy(char *to, const char *from) {
    assert(to != NULL && from != NULL);
    char *p = to;
    while ((*p++ = *from++) != '\0')
        ;
    return to;
}
\end{Code}


\subsection{strstr}


【解题思路】
实现 \fn{strstr}，子串查找函数，函数原型如下：
\begin{Code}
char * strstr(const char *haystack, const char *needle);
\end{Code}


\subsubsection{分析}
暴力算法的复杂度是 $O(m*n)$，代码如下。其他算法见第\S \ref{sec:substring-search}节 “子串查找”。


\subsubsection{代码}
\begin{Code}
char *strstr(const char *haystack, const char *needle) {
    // if needle is empty return the full string
    if (!*needle) return (char*) haystack;

    const char *p1;
    const char *p2;
    const char *p1_advance = haystack;
    for (p2 = &needle[1]; *p2; ++p2) {
        p1_advance++;   // advance p1_advance M-1 times
    }

    for (p1 = haystack; *p1_advance; p1_advance++) {
        char *p1_old = (char*) p1;
        p2 = needle;
        while (*p1 && *p2 && *p1 == *p2) {
            p1++;
            p2++;
        }
        if (!*p2) return p1_old;

        p1 = p1_old + 1;
    }
    return NULL;
}
\end{Code}


\subsubsection{相关题目}
与本题相同的题目：
\begindot
\item LeetCode Implement strStr(), \myurl{http://leetcode.com/oldoj\#question_28}
\myenddot

与本题相似的题目：
\begindot
\item  无
\myenddot


\subsection{atoi}
\label{sec:string-to-integer}


【解题思路】
实现 \fn{atoi}，将一个字符串转化为整数，函数原型如下：
\begin{Code}
int atoi(const char *str);
\end{Code}


\subsubsection{分析}
注意，这题是故意给很少的信息，让你来考虑所有可能的输入。

来看一下\fn{atoi}的官方文档(\myurl{http://www.cplusplus.com/reference/cstdlib/atoi/})，看看它有什么特性：

The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.

The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.

If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.

If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, \fn{INT_MAX (2147483647)} or \fn{INT_MIN (-2147483648)} is returned.

注意几个测试用例：
\begin{enumerate}
\item 不规则输入，但是有效，"-3924x8fc"， "  +  413",
\item 无效格式，" ++c", " ++1"
\item 溢出数据，"2147483648"
\end{enumerate}


\subsubsection{代码}
\begin{Code}
int atoi(const char *str) {
    int num = 0;
    int sign = 1;
    const int len = strlen(str);
    int i = 0;

    while (str[i] == ' ' && i < len) i++;

    if (str[i] == '+') i++;

    if (str[i] == '-') {
        sign = -1;
        i++;
    }

    for (; i < len; i++) {
        if (str[i] < '0' || str[i] > '9')
            break;
        if (num > INT_MAX / 10 ||
                (num == INT_MAX / 10 &&
                        (str[i] - '0') > INT_MAX % 10)) {
            return sign == -1 ? INT_MIN : INT_MAX;
        }
        num = num * 10 + str[i] - '0';
    }
    return num * sign;
}
\end{Code}

\subsection{Minimal Phases Covering}

We have words and there positions in a paragraph in sorted order. Write an 
algorithm to find the least distance for a given 3 words. 
eg. for 3 words 
job: 5, 9 , 17 
in: 4, 13, 18 
google: 8, 19, 21 
... 
... 
Answer: 17, 18, 19 
Can you extend it to "n" words? 

Context: In Google search results, the search terms are highlighted in the 
short paragraph that shows up. We need to find the shortest sentence that has 
all the words if we have word positions as mentioned above.

\subsubsection{分析}
Two solutions:
\begindot
	\item Coverte a graph to solve the shortest path
	\item Coverte a pair array to compress distice and cover all words, e.g.,
	
	word1: 1, 2, 8, 9
	
	word2: 2 4 5 8
	
	word2: 12 45 75
	
	....
	
	coverte them to a ordered pair array: (1, word1) (2, word1) (2, word2) (4, word2) (5, word2) (5, word2) (8, word1) (8, word2) (9, word1) (12, word3) (45, word3) (75, word3).
	now our goal is to find a minimum intersect that have all words, and have min(maxNumber-minNumber).
	we use two pointers to be left and right. When we have a full word list, we will check if Max-Min is smaller, as we have sorted ,so we have Max=right and Min=left. so we have 
	a O(nlgn) time complexity and O(n) space complexity as for save the type.
	
\myenddot

\begin{Code}
	int minPhrases(vector<int> &words){
		if(words.empty()) return 0;
		vector<int> indexs(word.size(),0);
		int mini = 0;
		make_heap();
		int minV, maxV, minDist=INT_MAX;
		for(int &i:indexs){
			
		}
	}
\end{Code}

\subsubsection{相关题目}
与本题相同的题目：
\begindot
\item LeetCode String to Integer (atoi), \myurl{http://leetcode.com/oldoj\#question_8}
\myenddot

与本题相似的题目：
\begindot
\item  无
\myenddot


\section{字符串排序} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{单词查找树} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{后缀数组} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{最长重复子串} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{最长公共子串}
\section{最长回文子串manacher算法}
\section{字符串散列}
求一个字符串设计一种散列

一种比较常见的方法是对于第i个字符，让它对散列的贡献值表示成$s[i]*p^i$，其中p为一个素数


\section{Makeup Palindrome String}
Given a string S, you are allowed to convert it to a palindrome by adding 0 or 
more characters in front of it. 
Find the length of the shortest palindrome that you can create from S by 
applying the above transformation. 

Note: O(n) time complexity and O(1) additinoal space.

\begin{Code}
	int FindPalindromeSize(string s){
		// n is the number of matching letters
		int n = 0;
		
		// r is the reverse string navigator
		for (int r = s.length() - 1; r >= 0; --r)
		{
			while(n > 0 && (s[r] != s[n]))
			{
				n--; // Keep subtracting n until we match again or reach the 
				beginning again
			}
			// If we have a match, move to the next letter
			if (s[r] == s[n]) { n++; }
		}
		
		// original string, plus the difference of non-palindrome-y letters
		// s.length() + s.length() - n;
		return (s.length()*2) - n;
	}
\end{Code}

\section{子串查找} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:substring-search}

字符串的一种基本操作就是\textbf{子串查找}(substring search)：给定一个长度为$N$的文本和一个长度为$M$的模式串(pattern string)，在文本中找到一个与该模式相符的子字符串。

最简单的算法是暴力查找，时间复杂度是$O(MN)$。下面介绍两个更高效的算法。


\subsection{KMP算法}
KMP算法是Knuth、Morris和Pratt在1976年发表的。它的基本思想是，当出现不匹配时，就能知晓一部分文本的内容（因为在匹配失败之前它们已经和模式相匹配）。我们可以利用这些信息避免将指针回退到所有这些已知的字符之前。这样，当出现不匹配时，可以提前判断如何重新开始查找，而这种判断只取决于模式本身。

详细解释请参考《算法》\footnote{《算法》，Robert Sedgewick，人民邮电出版社，\myurl{http://book.douban.com/subject/10432347/}}第5.3.3节。这本书讲的是确定有限状态自动机(DFA)的方法。

推荐网上的几篇比较好的博客，讲的是部分匹配表(partial match table)的方法（即next数组），“字符串匹配的KMP算法” \myurl{http://t.cn/zTOPfdh}，图文并茂，非常通俗易懂，作者是阮一峰；“KMP算法详解” \myurl{http://www.matrix67.com/blog/archives/115}，作者是顾森 Matrix67；"Knuth-Morris-Pratt string matching" \myurl{http://www.ics.uci.edu/~eppstein/161/960227.html}。

使用next数组的KMP算法的C语言实现如下。
\begin{Codex}[label=kmp.c]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*
 * @brief 计算部分匹配表，即next数组.
 *
 * @param[in] pattern 模式串
 * @param[out] next next数组
 * @return 无
 */
void compute_prefix(const char *pattern, int next[]) {
    int i;
    int j = -1;
    const int m = strlen(pattern);

    next[0] = j;
    for (i = 1; i < m; i++) {
        while (j > -1 && pattern[j + 1] != pattern[i]) j = next[j];

        if (pattern[i] == pattern[j + 1]) j++;
        next[i] = j;
    }
}

/*
 * @brief KMP算法.
 *
 * @param[in] text 文本
 * @param[in] pattern 模式串
 * @return 成功则返回第一次匹配的位置，失败则返回-1
 */
int kmp(const char *text, const char *pattern) {
    int i;
    int j = -1;
    const int n = strlen(text);
    const int m = strlen(pattern);
    if (n == 0 && m == 0) return 0; /* "","" */
    if (m == 0) return 0;  /* "a","" */
    int *next = (int*)malloc(sizeof(int) * m);

    compute_prefix(pattern, next);

    for (i = 0; i < n; i++) {
        while (j > -1 && pattern[j + 1] != text[i]) j = next[j];

        if (text[i] == pattern[j + 1]) j++;
        if (j == m - 1) {
            free(next);
            return i-j;
        }
    }

    free(next);
    return -1;
}


int main(int argc, char *argv[]) {
    char text[] = "ABC ABCDAB ABCDABCDABDE";
    char pattern[] = "ABCDABD";
    char *ch = text;
    int i = kmp(text, pattern);

    if (i >= 0) printf("matched @: %s\n", ch + i);
    return 0;
}
\end{Codex}


\subsection{Boyer-Moore算法}
详细解释请参考《算法》\footnote{《算法》，Robert Sedgewick，人民邮电出版社，\myurl{http://book.douban.com/subject/10432347/}}第5.3.4节。

推荐网上的几篇比较好的博客，“字符串匹配的Boyer-Moore算法” \myurl{http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html}，图文并茂，非常通俗易懂，作者是阮一峰；Boyer-Moore algorithm, \myurl{http://www-igm.univ-mlv.fr/~lecroq/string/node14.html}。

有兴趣的读者还可以看原始论文\footnote{BOYER R.S., MOORE J.S., 1977, A fast string searching algorithm. Communications of the ACM. 20:762-772.}。

Boyer-Moore算法的C语言实现如下。
\begin{Codex}[label=boyer_moore.c]
/**
 * 本代码参考了 http://www-igm.univ-mlv.fr/~lecroq/string/node14.html
 * 精力有限的话，可以只计算坏字符的后移，好后缀的位移是可选的，因此可以删除
 * suffixes(), pre_gs() 函数
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define ASIZE 256  /* ASCII字母的种类 */

/*
 * @brief 预处理，计算每个字母最靠右的位置.
 *
 * @param[in] pattern 模式串
 * @param[out] right 每个字母最靠右的位置
 * @return 无
 */
static void pre_right(const char *pattern, int right[]) {
    int i;
    const int m = strlen(pattern);

    for (i = 0; i < ASIZE; ++i) right[i] = -1;
    for (i = 0; i < m; ++i) right[(unsigned char)pattern[i]] = i;
}


static void suffixes(const char *pattern, int suff[]) {
    int f, g, i;
    const int m = strlen(pattern);

    suff[m - 1] = m;
    g = m - 1;
    for (i = m - 2; i >= 0; --i) {
        if (i > g && suff[i + m - 1 - f] < i - g)
            suff[i] = suff[i + m - 1 - f];
        else {
            if (i < g)
                g = i;
            f = i;
            while (g >= 0 && pattern[g] == pattern[g + m - 1 - f])
                --g;
            suff[i] = f - g;
        }
    }
}

/*
 * @brief 预处理，计算好后缀的后移位置.
 *
 * @param[in] pattern 模式串
 * @param[out] gs 好后缀的后移位置
 * @return 无
 */
static void pre_gs(const char pattern[], int gs[]) {
    int i, j;
    const int m = strlen(pattern);
    int *suff = (int*)malloc(sizeof(int) * (m + 1));

    suffixes(pattern, suff);

    for (i = 0; i < m; ++i) gs[i] = m;

    j = 0;
    for (i = m - 1; i >= 0; --i) if (suff[i] == i + 1)
        for (; j < m - 1 - i; ++j) if (gs[j] == m)
            gs[j] = m - 1 - i;
    for (i = 0; i <= m - 2; ++i)
        gs[m - 1 - suff[i]] = m - 1 - i;
    free(suff);
}

/**
 * @brief Boyer-Moore算法.
 *
 * @param[in] text 文本
 * @param[in] pattern 模式串
 * @return 成功则返回第一次匹配的位置，失败则返回-1
 */
int boyer_moore(const char *text, const char *pattern) {
    int i, j;
    int right[ASIZE];  /* bad-character shift */
    const int n = strlen(text);
    const int m = strlen(pattern);
    int *gs = (int*)malloc(sizeof(int) * (m + 1));  /* good-suffix shift */

    /* Preprocessing */
    pre_right(pattern, right);
    pre_gs(pattern, gs);

    /* Searching */
    j = 0;
    while (j <= n - m) {
        for (i = m - 1; i >= 0 && pattern[i] == text[i + j]; --i);

        if (i < 0) { /* 找到一个匹配 */
            /* printf("%d ", j);
            j += bmGs[0]; */
            free(gs);
            return j;
        } else {
            const int max = gs[i] > right[(unsigned char)text[i + j]] -
                    m + 1 + i ? gs[i] : i - right[(unsigned char)text[i + j]];
            j += max;
        }
    }
    free(gs);
    return -1;
}


int main() {
    const char *text="HERE IS A SIMPLE EXAMPLE";
    const char *pattern = "EXAMPLE";
    const int pos = boyer_moore(text, pattern);
    printf("%d\n", pos); /* 17 */
    return 0;
}
\end{Codex}


\subsection{Rabin-Karp算法}
详细解释请参考《算法》\footnote{《算法》，Robert Sedgewick，人民邮电出版社，\myurl{http://book.douban.com/subject/10432347/}}第5.3.5节。

Rabin-Karp算法的C语言实现如下。
\begin{Codex}[label=rabin_karp.c]
#include <stdio.h>
#include <string.h>

const int R = 256;  /** ASCII字母表的大小，R进制 */
/** 哈希表的大小，选用一个大素数，这里用16位整数范围内最大的素数 */
const long Q = 0xfff1;

/*
 * @brief 哈希函数.
 *
 * @param[in] key 待计算的字符串
 * @param[int] M 字符串的长度
 * @return 长度为M的子字符串的哈希值
 */
static long hash(const char key[], const int M) {
    int j;
    long h = 0;
    for (j = 0; j < M; ++j) h = (h * R + key[j]) % Q;
    return h;
}

/*
 * @brief 计算新的hash.
 *
 * @param[int] h 该段子字符串所对应的哈希值
 * @param[in] first 长度为M的子串的第一个字符
 * @param[in] next 长度为M的子串的下一个字符
 * @param[int] RM R^(M-1) % Q
 * @return 起始于位置i+1的M个字符的子字符串所对应的哈希值
 */
static long rehash(const long h, const char first, const char next,
                   const long RM) {
    long newh = (h + Q - RM * first % Q) % Q;
    newh = (newh * R + next) % Q;
    return newh;
}

/*
 * @brief 用蒙特卡洛算法，判断两个字符串是否相等.
 *
 * @param[in] pattern 模式串
 * @param[in] substring 原始文本长度为M的子串
 * @return 两个字符串相同，返回1，否则返回0
 */
static int check(const char *pattern, const char substring[]) {
    return 1;
}

/**
 * @brief Rabin-Karp算法.
 *
 * @param[in] text 文本
 * @param[in] n 文本的长度
 * @param[in] pattern 模式串
 * @param[in] m 模式串的长度
 * @return 成功则返回第一次匹配的位置，失败则返回-1
 */
int rabin_karp(const char *text, const char *pattern) {
    int i;
    const int n = strlen(text);
    const int m = strlen(pattern);
    const long pattern_hash = hash(pattern, m);
    long text_hash = hash(text, m);
    int RM = 1;
    for (i = 0; i < m - 1; ++i) RM = (RM * R) % Q;

    for (i = 0; i <= n - m; ++i) {
        if (text_hash == pattern_hash) {
            if (check(pattern, &text[i])) return i;
        }
        text_hash = rehash(text_hash, text[i], text[i + m], RM);
    }
    return -1;
}


int main() {
    const char *text = "HERE IS A SIMPLE EXAMPLE";
    const char *pattern = "EXAMPLE";
    const int pos = rabin_karp(text, pattern);
    printf("%d\n", pos); /* 17 */
    return 0;
}
\end{Codex}

\subsection{总结}
\vspace{1ex}
\begin{center}
\begin{tabular}{llccccc}
\hline
\multirow{2}{*}{\textbf{算法}} & \multirow{2}{*}{\textbf{版本}} & \multicolumn{2}{c}{\textbf{复杂度}} & \textbf{在文本} & \multirow{2}{*}{\textbf{正确性}} & \textbf{辅助}\\
\cline{3-4} & & \textbf{最坏情况} & \textbf{平均情况} & \textbf{中回退} & & \textbf{空间}\\
\hline
\multirow{3}{*}{KMP算法} & 完整的DFA & 2N & 1.1N & 否 & 是 & MR\\
                         & 部分匹配表 & 3N & 1.1N & 否 & 是 & M\\
						 & 完整版本 & 3N & N/M & 是 & 是 & R\\
\hline
Boyer-Moore算法 & 坏字符向后位移 & MN & N/M & 是 & 是 & R\\
\hline
\multirow{2}{*}{Rabin-Karp算法$^*$} & 蒙特卡洛算法 & 7N & 7N & 否 & 是$^*$ & 1\\
                         & 拉斯维加斯算法 & $7N^*$ & 7N & 是 & 是 & 1\\
\hline
\end{tabular}
\end{center}
\small{* 概率保证，需要使用均匀和独立的散列函数}


\section{正则表达式} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Same Pattern Match}
Given a pattern and a string input - find if the string follows 
the same pattern and return 0 or 1. 
Examples: 
1) Pattern : "abba", input: "redbluebluered" should return 1. 
2) Pattern: "aaaa", input: "asdasdasdasd" should return 1. 
3) Pattern: "aabb", input: "xyzabcxzyabc" should return 0. 

\section{LeetCode} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Interleaving String}
Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.

For example,

Given:

s1 = "aabcc",

s2 = "dbbca",

When s3 = "aadbbcbcac", return true.

When s3 = "aadbbbaccc", return false.

\subsubsection{思路}
【Iteration】 
s1取一部分，s2取一部分，然后再s1取一部分，反复直到匹配完成s3，算法去模拟这样的操作。

当s1和s3匹配了一部分的时候，剩下s1‘和剩下的s3’与s2又是一个子问题，则递归，但是需要注意两点：

1. 递归中，总是拿s1首先去匹配s3，如果不匹配，直接返回false，如此保持匹配是“交替”进行的；

2. 当出现既可以匹配s1，又可以匹配s2的时候，一样可以通过递归来解决，看下面的代码。
\begin{Code}
	bool isInterleave(string s1, string s2, string s3) {
		if(s3.size()!=s1.size()+s2.size()) return false;
		if(s1.empty()) return s2==s3;
		if(s2.empty()) return s1==s3;
		if(s1[0]!=s3[0]){
			if(s3[0]==s2[0])
				return isInterleave(s2,s1,s3);
			return false;
		}
		int i1=0, i3=0;
		while(i1<s1.size() && i3<s3.size() && s1[i1]==s3[i3]){
			i1++, i3++;
			if(s2[0]==s3[i3] && isInterleave(s2, s1.substr(i1), s3.substr(i3)))
				return true;
		}
		return isInterleave(s2, s1.substr(i1), s3.substr(i3));
	}
\end{Code}

【Danymic Programming】
动态规划矩阵matched[l1][l2]表示s1取l1长度（最后一个字母的pos是l1-1)，s2取l2长度(最后一个字母的pos是l2-1)，是否能匹配s3的l1+12长度。
$$match[l1][l2] = s1[l1-1] == s3[l1+l2-1] \&\& match[l1-1][l2] || s2[l2-1] == s3[l1+l2-1] \&\& match[l1][l2-1]$$

边界条件是，其中一个长度为0，另一个去匹配s3.

这里s1和s2交替出现的规律并不明显，所以没有直观地想到。

\begin{Code}
	bool isInterleave(string s1, string s2, string s3) {
		if(s3.size()!=s1.size()+s2.size()) return false;
		if(s1.empty()) return s2==s3;
		if(s2.empty()) return s1==s3;
		bool match[s1.size()+1][s2.size()+1];
		memset(match, 0x00, sizeof(match));
		match[0][0] = true;
		for(int i1=1;i1<=s1.size() && s1[i1-1]==s3[i1-1];i1++)
			match[i1][0] = true;
		for(int i2=1;i2<=s2.size() && s2[i2-1]==s3[i2-1];i2++)
			match[0][i2] = true;
		for(int i1=1;i1<=s1.size();i1++){
			for(int i2=1;i2<=s2.size();i2++){
				match[i1][i2] = (s1[i1-1] == s3[i1+i2-1] && match[i1-1][i2])
							||	(s2[i2-1] == s3[i1+i2-1] && match[i1][i2-1]);
			}
		}
		return match[s1.size()][s2.size()];
	}
\end{Code}

\subsection{Valid Palindrome} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:valid-palindrome}


【解题思路】
Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

For example,\\
\code{"A man, a plan, a canal: Panama"} is a palindrome.\\
\code{"race a car"} is not a palindrome.

Note:
Have you consider that the string might be empty? This is a good question to ask during an interview.

For the purpose of this problem, we define empty string as valid palindrome.


\subsubsection{分析}
无


\subsubsection{代码}
\begin{Code}
	// Leet Code, Valid Palindrome
	// 时间复杂度O(n)，空间复杂度O(1)
	class Solution {
		public:
		bool isPalindrome(string s) {
			transform(s.begin(), s.end(), s.begin(), ::tolower);
			auto left = s.begin(), right = prev(s.end());
			while (left < right) {
				if (!::isalnum(*left))  ++left;
				else if (!::isalnum(*right)) --right;
				else if (*left != *right) return false;
				else{ left++, right--; }
			}
			return true;
		}
	};
\end{Code}


\subsubsection{相关题目}
\begindot
\item Palindrome Number, 见 \S \ref{sec:palindrome-number}
\myenddot


\subsection{Implement strStr()} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:strstr}


【解题思路】
Implement strStr().

Returns a pointer to the first occurrence of needle in haystack, or null if needle is not part of haystack.


\subsubsection{分析}
暴力算法的复杂度是 $O(m*n)$，代码如下。更高效的的算法有KMP算法、Boyer-Mooer算法和Rabin-Karp算法。面试中暴力算法足够了，一定要写得没有BUG。


\subsubsection{暴力匹配}
\begin{Code}
	// LeetCode, Implement strStr()
	// 暴力解法，时间复杂度O(N*M)，空间复杂度O(1)
	class Solution {
		public:
		char *strStr(const char *haystack, const char *needle) {
			// if needle is empty return the full string
			if (!*needle) return (char*) haystack;
			
			const char *p1;
			const char *p2;
			const char *p1_advance = haystack;
			for (p2 = &needle[1]; *p2; ++p2) {
				p1_advance++;   // advance p1_advance M-1 times
			}
			
			for (p1 = haystack; *p1_advance; p1_advance++) {
				char *p1_old = (char*) p1;
				p2 = needle;
				while (*p1 && *p2 && *p1 == *p2) {
					p1++;
					p2++;
				}
				if (!*p2) return p1_old;
				
				p1 = p1_old + 1;
			}
			return nullptr;
		}
	};
\end{Code}


\subsubsection{KMP}
\begin{Code}
	// LeetCode, Implement strStr()
	// KMP，时间复杂度O(N+M)，空间复杂度O(M)
	class Solution {
		public:
		char *strStr(const char *haystack, const char *needle) {
			int pos = kmp(haystack, needle);
			if (pos == -1) return nullptr;
			else return (char*)haystack + pos;
		}
		private:
		/*
		* @brief 计算部分匹配表，即next数组.
		*
		* @param[in] pattern 模式串
		* @param[out] next next数组
		* @return 无
		*/
		static void compute_prefix(const char *pattern, int next[]) {
			int i;
			int j = -1;
			const int m = strlen(pattern);
			
			next[0] = j;
			for (i = 1; i < m; i++) {
				while (j > -1 && pattern[j + 1] != pattern[i]) j = next[j];
				
				if (pattern[i] == pattern[j + 1]) j++;
				next[i] = j;
			}
		}
		
		/*
		* @brief KMP算法.
		*
		* @param[in] text 文本
		* @param[in] pattern 模式串
		* @return 成功则返回第一次匹配的位置，失败则返回-1
		*/
		static int kmp(const char *text, const char *pattern) {
			int i;
			int j = -1;
			const int n = strlen(text);
			const int m = strlen(pattern);
			if (n == 0 && m == 0) return 0; /* "","" */
			if (m == 0) return 0;  /* "a","" */
			int *next = (int*)malloc(sizeof(int) * m);
			
			compute_prefix(pattern, next);
			
			for (i = 0; i < n; i++) {
				while (j > -1 && pattern[j + 1] != text[i]) j = next[j];
				
				if (text[i] == pattern[j + 1]) j++;
				if (j == m - 1) {
					free(next);
					return i-j;
				}
			}
			
			free(next);
			return -1;
		}
	};
\end{Code}


\subsubsection{相关题目}
\begindot
\item String to Integer (atoi) ，见 \S \ref{sec:string-to-integer}
\myenddot


\subsection{String to Integer (atoi)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:string-to-integer}


【解题思路】
Implement \fn{atoi} to convert a string to an integer.

\textbf{Hint}: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.

\textbf{Notes}: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.

\textbf{Requirements for atoi}:

The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional 
initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.

The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.

If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace 
characters, no conversion is performed.

If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, \code{INT_MAX (2147483647)} or \code{INT_MIN 
(-2147483648)} is returned.

\subsubsection{分析}
细节题。注意几个测试用例：
\begin{enumerate}
	\item 不规则输入，但是有效，"-3924x8fc"， "  +  413",
	\item 无效格式，" ++c", " ++1"
	\item 溢出数据，"2147483648"
\end{enumerate}

\subsubsection{代码}
\begin{Code}
	// LeetCode, String to Integer (atoi)
	// 时间复杂度O(n)，空间复杂度O(1)
	class Solution {
		public:
		int atoi(const char *str) {
			int num = 0;
			int sign = 1;
			const int n = strlen(str);
			int i = 0;
			
			while (str[i] == ' ' && i < n) i++;
			
			if (str[i] == '+') {
				i++;
			} else if (str[i] == '-') {
				sign = -1;
				i++;
		}
		
		for (; i < n; i++) {
			if (str[i] < '0' || str[i] > '9')
			break;
			if (num > INT_MAX / 10 ||
			(num == INT_MAX / 10 &&
			(str[i] - '0') > INT_MAX % 10)) {
			return sign == -1 ? INT_MIN : INT_MAX;
		}
		num = num * 10 + str[i] - '0';
	}
	return num * sign;
}
};
\end{Code}


\subsubsection{相关题目}
\begindot
\item Implement strStr() ，见 \S \ref{sec:strstr}
\myenddot


\subsection{Add Binary} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:add-binary}


【解题思路】
Given two binary strings, return their sum (also a binary string).

For example,
\begin{Code}
	a = "11"
	b = "1"
\end{Code}
Return {\small \fontspec{Latin Modern Mono} "100"}.


\subsubsection{分析}
无


\subsubsection{代码}
\begin{Code}
	//LeetCode, Add Binary
	// 时间复杂度O(n)，空间复杂度O(1)
	class Solution {
		public:
		string addBinary(string a, string b) {
			string result;
			const size_t n = a.size() > b.size() ? a.size() : b.size();
			reverse(a.begin(), a.end());
			reverse(b.begin(), b.end());
			int carry = 0;
			for (size_t i = 0; i < n; i++) {
				const int ai = i < a.size() ? a[i] - '0' : 0;
				const int bi = i < b.size() ? b[i] - '0' : 0;
				const int val = (ai + bi + carry) % 2;
				carry = (ai + bi + carry) / 2;
				result.insert(result.begin(), val + '0');
			}
			if (carry == 1) {
				result.insert(result.begin(), '1');
			}
			return result;
		}
	};
\end{Code}


\subsubsection{相关题目}
\begindot
\item Add Two Numbers, 见 \S \ref{sec:add-two-numbers}
\myenddot


\subsection{Longest Palindromic Substring} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:longest-palindromic-substring}


【解题思路】
Given a string $S$, find the longest palindromic substring in $S$. You may assume that the maximum length of $S$ is 1000, and there exists one unique longest palindromic substring.


\subsubsection{分析}
最长回文子串，非常经典的题。

思路一：暴力枚举，以每个元素为中间元素，同时从左右出发，复杂度$O(n^2)$。

思路二：记忆化搜索，复杂度$O(n^2)$。设\fn{f[i][j]} 表示[i,j]之间的最长回文子串，递推方程如下：
\begin{Code}
	f[i][j] = if (i == j) S[i]
	if (S[i] == S[j] && f[i+1][j-1] == S[i+1][j-1]) S[i][j]
	else max(f[i+1][j-1], f[i][j-1], f[i+1][j])
\end{Code}

思路三：动规，复杂度$O(n^2)$。设状态为\fn{f(i,j)}，表示区间[i,j]是否为回文串，则状态转移方程为
$$
f(i,j)=\begin{cases}
true & ,i=j\\
S[i]=S[j] & , j = i + 1 \\
S[i]=S[j] \text{ and } f(i+1, j-1) & , j > i + 1
\end{cases}
$$

思路三：Manacher’s Algorithm, 复杂度$O(n)$。详细解释见 \myurl{http://leetcode.com/2011/11/longest-palindromic-substring-part-ii.html} 。


\subsubsection{备忘录法}
\begin{Code}
	// LeetCode, Longest Palindromic Substring
	// 备忘录法，会超时
	// 时间复杂度O(n^2)，空间复杂度O(n^2)
	typedef string::const_iterator Iterator;
	
	namespace std {
		template<>
		struct hash<pair<Iterator, Iterator>> {
			size_t operator()(pair<Iterator, Iterator> const& p) const {
				return ((size_t) &(*p.first)) ^ ((size_t) &(*p.second));
			}
		};
	}
	
	class Solution {
		public:
		string longestPalindrome(string const& s) {
			cache.clear();
			return cachedLongestPalindrome(s.begin(), s.end());
		}
		
		private:
		unordered_map<pair<Iterator, Iterator>, string> cache;
		
		string longestPalindrome(Iterator first, Iterator last) {
			size_t length = distance(first, last);
			
			if (length < 2) return string(first, last);
			
			auto s = cachedLongestPalindrome(next(first), prev(last));
			
			if (s.length() == length - 2 && *first == *prev(last))
			return string(first, last);
			
			auto s1 = cachedLongestPalindrome(next(first), last);
			auto s2 = cachedLongestPalindrome(first, prev(last));
			
			// return max(s, s1, s2)
			if (s.size() > s1.size()) return s.size() > s2.size() ? s : s2;
			else return s1.size() > s2.size() ? s1 : s2;
		}
		
		string cachedLongestPalindrome(Iterator first, Iterator last) {
			auto key = make_pair(first, last);
			auto pos = cache.find(key);
			
			if (pos != cache.end()) return pos->second;
			else return cache[key] = longestPalindrome(first, last);
		}
	};
\end{Code}


\subsubsection{动规}
\begin{Code}
	// LeetCode, Longest Palindromic Substring
	// 动规，时间复杂度O(n^2)，空间复杂度O(n^2)
	class Solution {
		public:
		string longestPalindrome(string s) {
			const int n = s.size();
			bool f[n][n];
			fill_n(&f[0][0], n * n, false);
			// 用 vector 会超时
			//vector<vector<bool> > f(n, vector<bool>(n, false));
			size_t max_len = 1, start = 0;  // 最长回文子串的长度，起点
			
			for (size_t i = 0; i < s.size(); i++) {
				f[i][i] = true;
				for (size_t j = 0; j < i; j++) {  // [j, i]
					f[j][i] = (s[j] == s[i] && (i - j < 2 || f[j + 1][i - 1]));
					if (f[j][i] && max_len < (i - j + 1)) {
						max_len = i - j + 1;
						start = j;
					}
				}
			}
			return s.substr(start, max_len);
		}
	};
\end{Code}


\subsubsection{Manacher’s Algorithm}
\begin{Code}
	// LeetCode, Longest Palindromic Substring
	// Manacher’s Algorithm
	// 时间复杂度O(n)，空间复杂度O(n)
	class Solution {
		public:
		// Transform S into T.
		// For example, S = "abba", T = "^#a#b#b#a#$".
		// ^ and $ signs are sentinels appended to each end to avoid bounds checking
		string preProcess(string s) {
			int n = s.length();
			if (n == 0) return "^$";
			
			string ret = "^";
			for (int i = 0; i < n; i++) ret += "#" + s.substr(i, 1);
			
			ret += "#$";
			return ret;
		}
		
		string longestPalindrome(string s) {
			string T = preProcess(s);
			const int n = T.length();
			// 以T[i]为中心，向左/右扩张的长度，不包含T[i]自己，
			// 因此 P[i]是源字符串中回文串的长度
			int P[n];
			int C = 0, R = 0;
			
			for (int i = 1; i < n - 1; i++) {
				int i_mirror = 2 * C - i; // equals to i' = C - (i-C)
				
				P[i] = (R > i) ? min(R - i, P[i_mirror]) : 0;
				
				// Attempt to expand palindrome centered at i
				while (T[i + 1 + P[i]] == T[i - 1 - P[i]])
				P[i]++;
				
				// If palindrome centered at i expand past R,
				// adjust center based on expanded palindrome.
				if (i + P[i] > R) {
					C = i;
					R = i + P[i];
				}
			}
			
			// Find the maximum element in P.
			int max_len = 0;
			int center_index = 0;
			for (int i = 1; i < n - 1; i++) {
				if (P[i] > max_len) {
					max_len = P[i];
					center_index = i;
				}
			}
			
			return s.substr((center_index - 1 - max_len) / 2, max_len);
		}
	};
\end{Code}


\subsubsection{相关题目}
\begindot
\item 无
\myenddot


\subsection{Regular Expression Matching} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:regular-expression-matching}


【解题思路】
Implement regular expression matching with support for \fn{'.'} and \fn{'*'}.

\fn{'.'} Matches any single character.
\fn{'*'} Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

The function prototype should be:
\begin{Code}
	bool isMatch(const char *s, const char *p)
\end{Code}

Some examples:
\begin{Code}
	isMatch("aa","a") → false
	isMatch("aa","aa") → true
	isMatch("aaa","aa") → false
	isMatch("aa", "a*") → true
	isMatch("aa", ".*") → true
	isMatch("ab", ".*") → true
	isMatch("aab", "c*a*b") → true
\end{Code}


\subsubsection{分析}
这是一道很有挑战的题。


\subsubsection{递归版}
\begin{Code}
	// LeetCode, Regular Expression Matching
	// 递归版，时间复杂度O(n)，空间复杂度O(1)
	class Solution {
		public:
		bool isMatch(const char *s, const char *p) {
			if (*p == '\0') return *s == '\0';
			
			// next char is not '*', then must match current character
			if (*(p + 1) != '*') {
				if (*p == *s || (*p == '.' && *s != '\0'))
				return isMatch(s + 1, p + 1);
				else
				return false;
			} else { // next char is '*'
			while (*p == *s || (*p == '.' && *s != '\0')) {
				if (isMatch(s, p + 2))
				return true;
				s++;
			}
			return isMatch(s, p + 2);
		}
	}
};
\end{Code}


\subsubsection{迭代版}
\begin{Code}
	
\end{Code}


\subsubsection{相关题目}
\begindot
\item Wildcard Matching, 见 \S \ref{sec:wildcard-matching}
\myenddot


\subsection{Wildcard Matching} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:wildcard-matching}


【解题思路】
Implement wildcard pattern matching with support for \fn{'?'} and \fn{'*'}.

\fn{'?'} Matches any single character.
\fn{'*'} Matches any sequence of characters (including the empty sequence).

The matching should cover the entire input string (not partial).

The function prototype should be:
\begin{Code}
	bool isMatch(const char *s, const char *p)
\end{Code}

Some examples:
\begin{Code}
	isMatch("aa","a") → false
	isMatch("aa","aa") → true
	isMatch("aaa","aa") → false
	isMatch("aa", "*") → true
	isMatch("aa", "a*") → true
	isMatch("ab", "?*") → true
	isMatch("aab", "c*a*b") → false
\end{Code}


\subsubsection{分析}
跟上一题很类似。

主要是\fn{'*'}的匹配问题。\fn{p}每遇到一个\fn{'*'}，就保留住当前\fn{'*'}的坐标和\fn{s}的坐标，然后\fn{s}从前往后扫描，如果不成功，则\fn{s++}，重新扫描。


\subsubsection{递归版}
\begin{Code}
	// LeetCode, Wildcard Matching
	// 递归版，会超时，用于帮助理解题意
	// 时间复杂度O(n!*m!)，空间复杂度O(n)
	class Solution {
		public:
		bool isMatch(const char *s, const char *p) {
			if (*p == '*') {
				while (*p == '*') ++p;  //skip continuous '*'
				if (*p == '\0') return true;
				while (*s != '\0' && !isMatch(s, p)) ++s;
				
				return *s != '\0';
			}
			else if (*p == '\0' || *s == '\0') return *p == *s;
			else if (*p == *s || *p == '?') return isMatch(++s, ++p);
			else return false;
		}
	};
\end{Code}


\subsubsection{迭代版}
\begin{Code}
	// LeetCode, Wildcard Matching
	// 迭代版，时间复杂度O(n*m)，空间复杂度O(1)
	class Solution {
		public:
		bool isMatch(const char *s, const char *p) {
			bool star = false;
			const char *str, *ptr;
			for (str = s, ptr = p; *str != '\0'; str++, ptr++) {
				switch (*ptr) {
					case '?':
					break;
					case '*':
					star = true;
					s = str, p = ptr;
					while (*p == '*') p++;  //skip continuous '*'
					if (*p == '\0') return true;
					str = s - 1;
					ptr = p - 1;
					break;
					default:
					if (*str != *ptr) {
						// 如果前面没有'*'，则匹配不成功
						if (!star) return false;
						s++;
						str = s - 1;
						ptr = p - 1;
					}
				}
			}
			while (*ptr == '*') ptr++;
			return (*ptr == '\0');
		}
	};
\end{Code}


\subsubsection{相关题目}
\begindot
\item Regular Expression Matching, 见 \S \ref{sec:regular-expression-matching}
\myenddot


\subsection{Longest Common Prefix} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:longest-common-prefix}


【解题思路】
Write a function to find the longest common prefix string amongst an array of strings.


\subsubsection{分析}
从位置0开始，对每一个位置比较所有字符串，直到遇到一个不匹配。


\subsubsection{纵向扫描}
\begin{Code}
	// LeetCode, Longest Common Prefix
	// 纵向扫描，从位置0开始，对每一个位置比较所有字符串，直到遇到一个不匹配
	// 时间复杂度O(n1+n2+...)
	// @author 周倩 (http://weibo.com/zhouditty)
	class Solution {
		public:
		string longestCommonPrefix(vector<string> &strs) {
			if (strs.empty()) return "";
			
			for (int idx = 0; idx < strs[0].size(); ++idx) { // 纵向扫描
				for (int i = 1; i < strs.size(); ++i) {
					if (strs[i][idx] != strs[0][idx]) return strs[0].substr(0,idx);
				}
			}
			return strs[0];
		}
	};
\end{Code}


\subsubsection{横向扫描}
\begin{Code}
	// LeetCode, Longest Common Prefix
	// 横向扫描，每个字符串与第0个字符串，从左到右比较，直到遇到一个不匹配，
	// 然后继续下一个字符串
	// 时间复杂度O(n1+n2+...)
	class Solution {
		public:
		string longestCommonPrefix(vector<string> &strs) {
			if (strs.empty()) return "";
			
			int right_most = strs[0].size() - 1;
			for (size_t i = 1; i < strs.size(); i++)
			for (int j = 0; j <= right_most; j++)
			if (strs[i][j] != strs[0][j])  // 不会越界，请参考string::[]的文档
			right_most = j - 1;
			
			return strs[0].substr(0, right_most + 1);
		}
	};
\end{Code}


\subsubsection{相关题目}
\begindot
\item 无
\myenddot


\subsection{Valid Number} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:valid-number}


【解题思路】
Validate if a given string is numeric.

Some examples:
\begin{Code}
	"0" => true
	" 0.1 " => true
	"abc" => false
	"1 a" => false
	"2e10" => true
\end{Code}

Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.


\subsubsection{分析}
细节实现题。

本题的功能与标准库中的\fn{strtod()}功能类似。


\subsubsection{有限自动机}
\begin{Code}
	// LeetCode, Valid Number
	// @author 龚陆安 (http://weibo.com/luangong)
	// finite automata，时间复杂度O(n)，空间复杂度O(n)
	class Solution {
		public:
		bool isNumber(const char *s) {
			enum InputType {
				INVALID,    // 0
				SPACE,      // 1
				SIGN,       // 2
				DIGIT,      // 3
				DOT,        // 4
				EXPONENT,   // 5
				NUM_INPUTS  // 6
			};
			const int transitionTable[][NUM_INPUTS] = {
				-1, 0, 3, 1, 2, -1, // next states for state 0
				-1, 8, -1, 1, 4, 5,     // next states for state 1
				-1, -1, -1, 4, -1, -1,     // next states for state 2
				-1, -1, -1, 1, 2, -1,     // next states for state 3
				-1, 8, -1, 4, -1, 5,     // next states for state 4
				-1, -1, 6, 7, -1, -1,     // next states for state 5
				-1, -1, -1, 7, -1, -1,     // next states for state 6
				-1, 8, -1, 7, -1, -1,     // next states for state 7
				-1, 8, -1, -1, -1, -1,     // next states for state 8
			};
			
			int state = 0;
			for (; *s != '\0'; ++s) {
				InputType inputType = INVALID;
				if (isspace(*s))
				inputType = SPACE;
				else if (*s == '+' || *s == '-')
				inputType = SIGN;
				else if (isdigit(*s))
				inputType = DIGIT;
				else if (*s == '.')
				inputType = DOT;
				else if (*s == 'e' || *s == 'E')
				inputType = EXPONENT;
				
				// Get next state from current state and input symbol
				state = transitionTable[state][inputType];
				
				// Invalid input
				if (state == -1) return false;
			}
			// If the current state belongs to one of the accepting (final) states,
			// then the number is valid
			return state == 1 || state == 4 || state == 7 || state == 8;
			
		}
	};
\end{Code}


\subsubsection{使用strtod()}
\begin{Code}
	// LeetCode, Valid Number
	// @author 连城 (http://weibo.com/lianchengzju)
	// 偷懒，直接用 strtod()，时间复杂度O(n)
	class Solution {
		public:
		bool isNumber (char const* s) {
			char* endptr;
			strtod (s, &endptr);
			
			if (endptr == s) return false;
			
			for (; *endptr; ++endptr)
			if (!isspace (*endptr)) return false;
			
			return true;
		}
	};
\end{Code}


\subsubsection{相关题目}
\begindot
\item 无
\myenddot


\subsection{Integer to Roman} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:integer-to-roman}


【解题思路】
Given an integer, convert it to a roman numeral.

Input is guaranteed to be within the range from 1 to 3999.


\subsubsection{分析}
无


\subsubsection{代码}
\begin{Code}
	// LeetCode, Integer to Roman
	// 时间复杂度O(num)，空间复杂度O(1)
	class Solution {
		public:
		string intToRoman(int num) {
			const int radix[] = {1000, 900, 500, 400, 100, 90,
				50, 40, 10, 9, 5, 4, 1};
			const string symbol[] = {"M", "CM", "D", "CD", "C", "XC",
				"L", "XL", "X", "IX", "V", "IV", "I"};
			
			string roman;
			for (size_t i = 0; num > 0; ++i) {
				int count = num / radix[i];
				num %= radix[i];
				for (; count > 0; --count) roman += symbol[i];
			}
			return roman;
		}
	};
\end{Code}


\subsubsection{相关题目}
\begindot
\item Roman to Integer, 见 \S \ref{sec:roman-to-integer}
\myenddot


\subsection{Roman to Integer} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:roman-to-integer}


【解题思路】
Given a roman numeral, convert it to an integer.

Input is guaranteed to be within the range from 1 to 3999.


\subsubsection{分析}
从前往后扫描，用一个临时变量记录分段数字。

如果当前比前一个大，说明这一段的值应该是当前这个值减去上一个值。比如\fn{IV = 5 – 1}；否则，将当前值加入到结果中，然后开始下一段记录。比如\fn{VI = 5 + 1, II=1+1}


\subsubsection{代码}
\begin{Code}
	// LeetCode, Roman to Integer
	// 时间复杂度O(n)，空间复杂度O(1)
	class Solution {
		public:
		inline int map(const char c) {
			switch (c) {
				case 'I': return 1;
				case 'V': return 5;
				case 'X': return 10;
				case 'L': return 50;
				case 'C': return 100;
				case 'D': return 500;
				case 'M': return 1000;
				default: return 0;
			}
		}
		
		int romanToInt(string s) {
			int result = 0;
			for (size_t i = 0; i < s.size(); i++) {
				if (i > 0 && map(s[i]) > map(s[i - 1])) {
					result += (map(s[i]) - 2 * map(s[i - 1]));
				} else {
				result += map(s[i]);
			}
		}
		return result;
	}
};
\end{Code}


\subsubsection{相关题目}
\begindot
\item Integer to Roman, 见 \S \ref{sec:integer-to-roman}
\myenddot


\subsection{Count and Say} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:count-and-say}


【解题思路】
The count-and-say sequence is the sequence of integers beginning as follows:
\begin{Code}
	1, 11, 21, 1211, 111221, ...
\end{Code}

\fn{1} is read off as \fn{"one 1"} or \fn{11}.

\fn{11} is read off as \fn{"two 1s"} or \fn{21}.

\fn{21} is read off as \fn{"one 2"}, then \fn{"one 1"} or \fn{1211}.

Given an integer $n$, generate the nth sequence.

Note: The sequence of integers will be represented as a string.


\subsubsection{分析}
模拟。


\subsubsection{代码}
\begin{Code}
	// LeetCode, Count and Say
	// @author 连城 (http://weibo.com/lianchengzju)
	// 时间复杂度O(n^2)，空间复杂度O(n)
	class Solution {
		public:
		string countAndSay(int n) {
			string s("1");
			
			while (--n)
			s = getNext(s);
			
			return s;
		}
		
		string getNext(const string &s) {
			stringstream ss;
			
			for (auto i = s.begin(); i != s.end(); ) {
				auto j = find_if(i, s.end(), bind1st(not_equal_to<char>(), *i));
				ss << distance(i, j) << *i;
				i = j;
			}
			
			return ss.str();
		}
	};
\end{Code}


\subsubsection{相关题目}
\begindot
\item 无
\myenddot


\subsection{Anagrams} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:anagrams}


【解题思路】
Given an array of strings, return all groups of strings that are anagrams.

Note: All inputs will be in lower-case.


\subsubsection{分析}
Anagram（回文构词法）是指打乱字母顺序从而得到新的单词，比如 \fn{"dormitory"} 打乱字母顺序会变成 \fn{"dirty room"} ，\fn{"tea"} 会变成\fn{"eat"}。

回文构词法有一个特点：单词里的字母的种类和数目没有改变，只是改变了字母的排列顺序。因此，将几个单词按照字母顺序排序后，若它们相等，则它们属于同一组 anagrams 。


\subsubsection{代码}
\begin{Code}
	// LeetCode, Anagrams
	// 时间复杂度O(n)，空间复杂度O(n)
	class Solution {
		public:
		vector<string> anagrams(vector<string> &strs) {
			unordered_map<string, vector<string> > group;
			for (const auto &s : strs) {
				string key = s;
				sort(key.begin(), key.end());
				group[key].push_back(s);
			}
			
			vector<string> result;
			for (auto it = group.cbegin(); it != group.cend(); it++) {
				if (it->second.size() > 1)
				result.insert(result.end(), it->second.begin(), it->second.end());
			}
			return result;
		}
	};
\end{Code}


\subsubsection{相关题目}
\begindot
\item 无
\myenddot


\subsection{Simplify Path} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:simplify-path}


【解题思路】
Given an absolute path for a file (Unix-style), simplify it.

For example, \\
path = \fn{"/home/"}, => \fn{"/home"} \\
path = \fn{"/a/./b/../../c/"}, => \fn{"/c"} \\

Corner Cases:
\begindot
\item Did you consider the case where path = \fn{"/../"}? 
In this case, you should return \fn{"/"}.
\item 
Another corner case is the path might contain multiple slashes \fn{'/'} together, such as \fn{"/home//foo/"}.
In this case, you should ignore redundant slashes and return \fn{"/home/foo"}.
\myenddot


\subsubsection{分析}
很有实际价值的题目。


\subsubsection{代码}
\begin{Code}
	// LeetCode, Simplify Path
	// 时间复杂度O(n)，空间复杂度O(n)
	class Solution {
		public:
		string simplifyPath(string const& path) {
			vector<string> dirs; // 当做栈
			
			for (auto i = path.begin(); i != path.end();) {
				++i;
				
				auto j = find(i, path.end(), '/');
				auto dir = string(i, j);
				
				if (!dir.empty() && dir != ".") {// 当有连续 '///'时，dir 为空
					if (dir == "..") {
						if (!dirs.empty())
						dirs.pop_back();
					} else
					dirs.push_back(dir);
				}
				
				i = j;
			}
			
			stringstream out;
			if (dirs.empty()) {
				out << "/";
			} else {
			for (auto dir : dirs)
			out << '/' << dir;
		}
		
		return out.str();
	}
};
\end{Code}


\subsubsection{相关题目}
\begindot
\item 无
\myenddot


\subsection{Length of Last Word} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:length-of-last-word}


【解题思路】
Given a string s consists of upper/lower-case alphabets and empty space characters \fn{' '}, return the length of last word in the string.

If the last word does not exist, return 0.

Note: A word is defined as a character sequence consists of non-space characters only.

For example, 
Given \fn{s = "Hello World"},
return 5.


\subsubsection{分析}
细节实现题。


\subsubsection{用 STL}
\begin{Code}
	// LeetCode, Length of Last Word
	// 偷懒，用 STL
	// 时间复杂度O(n)，空间复杂度O(1)
	class Solution {
		public:
		int lengthOfLastWord(const char *s) {
			const string str(s);
			auto first = find_if(str.rbegin(), str.rend(), ::isalpha);
			auto last = find_if_not(first, str.rend(), ::isalpha);
			return distance(first, last);
		}
	};
\end{Code}


\subsubsection{顺序扫描}
\begin{Code}
	// LeetCode, Length of Last Word
	// 顺序扫描，记录每个 word 的长度
	// 时间复杂度O(n)，空间复杂度O(1)
	class Solution {
		public:
		int lengthOfLastWord(const char *s) {
			int len = 0;
			while (*s) {
				if (*s++ != ' ')
				++len;
				else if (*s && *s != ' ')
				len = 0;
			}
			return len;
		}
	};
\end{Code}


\subsubsection{相关题目}
\begindot
\item 无
\myenddot

\subsection{Random Weight}
Write a function that receives a stream of pairs: id (some unique integer) + weight (positive real number). 
The stream ends with the special pair {0,0}. 
The function should return one the unique ids at random, with probability proportional to its weight (compared to the total weights sum when stream has ended). 
Stream size and weights sum are unknown in advance, and you are allowed O(1) memory consumption. 

Example: If this was the stream: {1,2},{2,2},{3,4},{4,10}, then id 2 would be returned with probability 1/9.

\subsection{Print ASCII}
Write a function that prints all ASCII characters. You are not allowed to use for/while loop.
\begin{Code}
	// Google Interview, Print ASCII
	class Solution {
		void printAscii(){
			printAscii();
		}
		void printAscii(int c) {
			if(c>=129)
				return;
			cout<<(char)c<<endl;
			printAscii(c+1);
		}
	}
\end{Code}

\subsection{Inplace Reverse sentence}
You given a sentence of english words and spaces between them. 
Nothing crazy: 
1) no double spaces 
2) no empty words 
3) no spaces at the ends of a sentence


void inplace_reverse(char* arr, int length) {
	// your solution
}
Example: 

input "I wish you a merry Christmas" 

output "Christmas merry a you wish I" 

Constrains: O(1) additional memory

\begin{Code}
	void reverseword(char *word,int len){
		if(word==nullptr || len<1) return;
		reverse(word, word+len);
	}
	void reverseSentence(char *arr, int length){
		if(arr==nullptr || length<1) return;
		
		int wordbegin = 0;
		for(int i=0;i<length;i++){
			if(arr[i]!=' ') continue;
			reverseword(arr+wordbegin,i-wordbegin-1);
			wordbegin = i+1;
		}
		reverseword(arr,length);
	}
\end{Code}

\subsection{Inverse Index}
Given a string, you need to find super string by word match. i.e. all words in the input string has to occure in any order in output string. 
e.g. given data set: \\
"string search" \\
"java string search" \\
"manual c++ string search equals" \\
"java search code" \\
"c++ java code search" \\
... \\

input: "java search" \\
output: \\
1) "java string search" \\
2) "java search code" \\
3) "c++ java code search" \\

input: "c++ search" \\
output: \\
1) "manual c++ string search equals" \\
2) "c++ java code search" \\

There are millions of records in given data set and you need to process few million as input.

\begin{Code}
	Loop each string, adding the words into a hashmap on the word => string ID. For example: 
	
	java => 1, 3, 4 
	search => 0, 1, 2, 3, 4 
	
	To find "java search", look up each word in our map and intersect the results, i.e. we get 1, 3, 4 in this case. 
	
	Therefore the result is: 
	
	"java string search" 
	"java search code" 
	"c++ java code search" 
\end{Code}

\subsection{atoi}
Implement a function that convert asci value to int.